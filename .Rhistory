dat.temp = dat.temp[which(dat.temp$treat_sd >= 0),]
effect.sizes.temp = tryCatch({
effect.size.calculation.function(data = dat.temp,effect.size.metric = effect.size.metric)
}, error = function(e){
return(NA)
})
if(length(effect.sizes.temp) == 1){
effect.sizes.temp = data.frame("vi"=rep(NA, nrow(dat.temp)),"yi"=rep(NA, nrow(dat.temp)))}
#effect.sizes.temp = effect.sizes.temp[which(!(effect.sizes.temp$vi == 0)),] # probably not neccessary
data.missing.rma.results = tryCatch({
meta_analysis.function(effect.sizes.temp)
}, error = function(e){
return(NA)
})
if(length(data.missing.rma.results) == 1){
data.missing.rma.results =  data.frame("grand_mean" = NA,
"grand_mean_lb" = NA,
"grand_mean_ub" = NA,
"sample_size_for_rma_calc" = NA)}
data.size.temp <<- nrow(dat.temp)
return(data.missing.rma.results)
}
one.complete.imp.method.run = function(dat.raw,data.sample.size.percentage, imputation.method.temp,
deletion.chance.slope, deletion.minimum, deletion.maximum,
deletion.step, repetitions.per.step,effect.size.metric){
del.rate.vector = sort(rep(seq(from = deletion.minimum,to=deletion.maximum,by = deletion.step),repetitions.per.step))
result.df.one.imp.method = data.frame("deletion_rate"= NA,
"grand_mean"= NA,
"grand_mean_lb"= NA,
"grand_mean_ub"= NA,
"sample_size_for_rma_calc"=NA)[0,]
for(del.rate.temp in del.rate.vector){
result.one.run =  one.run.of.grand.mean.calculation.function(
dat.temp =dat.raw,
data.sample.size.percentage = data.sample.size.percentage,
del.rate.temp = del.rate.temp,
deletion.chance.slope = deletion.chance.slope,
imputation.method.temp = imputation.method.temp,
effect.size.metric = effect.size.metric)
result.df.one.run = data.frame("deletion_rate"= del.rate.temp,
"grand_mean"= result.one.run$grand_mean,
"grand_mean_lb"= result.one.run$grand_mean_lb,
"grand_mean_ub"= result.one.run$grand_mean_ub,
"sample_size_for_rma_calc"=result.one.run$sample_size_for_rma_calc)
result.df.one.imp.method = rbind(result.df.one.imp.method,result.df.one.run)
print(del.rate.temp)
}
return(result.df.one.imp.method)
}
run.over.all.methods = function(dat.raw , data.sample.size.percentage, imp.methods.vector,
deletion.chance.slope, deletion.minimum, deletion.maximum,
deletion.step, repetitions.per.step, data.size,effect.size.metric){
result.df = data.frame("imputation_method"=NA,"data_size"=NA,"deletion_rate"=NA,"effect_size"=NA,
"grand_mean"=NA,"grand_mean_lb"=NA,"grand_mean_ub"=NA,"sample_size_for_rma_calc"=NA)[0,]
for(method.temp in imp.methods.vector){
result.df.one.imp.method = one.complete.imp.method.run(dat.raw = dat.raw,
data.sample.size.percentage = data.sample.size.percentage,
imputation.method.temp = method.temp,
deletion.minimum = deletion.minimum,
deletion.maximum = deletion.maximum,
deletion.step = deletion.step,
repetitions.per.step = repetitions.per.step,
deletion.chance.slope = deletion.chance.slope,
effect.size.metric = effect.size.metric)
result.df.one.imp.method$imputation_method = method.temp
result.df.one.imp.method$data_size = data.sample.size.percentage
result.df.one.imp.method$effect_size = effect.size.metric
result.df = rbind(result.df, result.df.one.imp.method)
}
return(result.df)
}
test = run.over.all.methods(dat.raw = dat.raw,
data.sample.size.percentage = 1,
imp.methods.vector = c("sample","mean","pmm","norm.nob","norm.boot","norm.predict",
"norm","cart","rf"),
deletion.chance.slope = 1,
deletion.minimum = 0.1,
deletion.maximum = 0.9,
deletion.step = 0.1,
repetitions.per.step = 0.1,
data.size = 1,
effect.size.metric = "ROM")
test = run.over.all.methods(dat.raw = dat.raw,
data.sample.size.percentage = 1,
imp.methods.vector = c("sample","mean","pmm","norm.nob","norm.boot","norm.predict","norm","cart","rf"),
deletion.chance.slope = 1,
deletion.minimum = 0.1,
deletion.maximum = 0.9,
deletion.step = 0.1,
repetitions.per.step = 0.1,
data.size = 1,
effect.size.metric = "ROM")
test = run.over.all.methods(dat.raw = dat.raw,
data.sample.size.percentage = 1,
imp.methods.vector = c("sample","mean","pmm","norm.nob","norm.boot","norm.predict","norm","cart","rf"),
deletion.chance.slope = 1,
deletion.minimum = 0.1,
deletion.maximum = 0.9,
deletion.step = 0.1,
repetitions.per.step = 0.1,
data.size = 1,
effect.size.metric = "ROM")
dat.raw = dat.raw
data.sample.size.percentage = 1
imp.methods.vector = c("sample","mean","pmm","norm.nob","norm.boot","norm.predict","norm","cart","rf")
deletion.chance.slope = 1
deletion.minimum = 0.1
deletion.maximum = 0.9
deletion.step = 0.1
repetitions.per.step = 0.1
data.size = 1
effect.size.metric = "ROM"
result.df = data.frame("imputation_method"=NA,"data_size"=NA,"deletion_rate"=NA,"effect_size"=NA,
"grand_mean"=NA,"grand_mean_lb"=NA,"grand_mean_ub"=NA,"sample_size_for_rma_calc"=NA)[0,]
for(method.temp in imp.methods.vector){
result.df.one.imp.method = one.complete.imp.method.run(dat.raw = dat.raw,
data.sample.size.percentage = data.sample.size.percentage,
imputation.method.temp = method.temp,
deletion.minimum = deletion.minimum,
deletion.maximum = deletion.maximum,
deletion.step = deletion.step,
repetitions.per.step = repetitions.per.step,
deletion.chance.slope = deletion.chance.slope,
effect.size.metric = effect.size.metric)
result.df.one.imp.method$imputation_method = method.temp
result.df.one.imp.method$data_size = data.sample.size.percentage
result.df.one.imp.method$effect_size = effect.size.metric
result.df = rbind(result.df, result.df.one.imp.method)
}
result.df.one.imp.method
dat.raw = dat.raw
data.sample.size.percentage = data.sample.size.percentage
imputation.method.temp = method.temp
deletion.minimum = deletion.minimum
deletion.maximum = deletion.maximum
deletion.step = deletion.step
repetitions.per.step = repetitions.per.step
deletion.chance.slope = deletion.chance.slope
effect.size.metric = effect.size.metric
del.rate.vector = sort(rep(seq(from = deletion.minimum,to=deletion.maximum,by = deletion.step),repetitions.per.step))
del.rate.vector
deletion.minimum
dat.raw
del.rate.vector
deletion.minimum
deletion.maximum
deletion.step
sort(rep(seq(from = deletion.minimum,to=deletion.maximum,by = deletion.step),repetitions.per.step))
rep(seq(from = deletion.minimum,to=deletion.maximum,by = deletion.step),repetitions.per.step)
seq(from = deletion.minimum,to=deletion.maximum,by = deletion.step)
repetitions.per.step
### Testing multiple imputation methods for estimating missing
### standard deviations in a real dataset
###
### Author: Stephan Kambach
### Date: 28.04.2015
#############################################
# libraries --------------------------------
library(mice)
#library(mi)
#library(Amelia)
#library(mitools)
#library(pan)
library(ggplot2)
library(metafor)
library(ROCR)
library(data.table)
#############################################
# read data ---------------------------------
dat.raw = read.csv("C:\\Users\\Agando\\Desktop\\aktuelle Arbeiten\\SESYNC_multiple_imputation\\LUBDES_multiple_imputations\\MA_Gerstner2014_complete_observations.csv",
header=T)
dat.raw = dat.raw[,-1]
str(dat.raw)
names(dat.raw) = c("reference","biodiv_aspect","control_n","treat_n","control_mean","treat_mean","control_sd","treat_sd")
#############################################
# cleaning and standard error calculation
dat.raw = dat.raw[-419,] # clear outlier
dat.raw = dat.raw[- which(duplicated(dat.raw)),]
dat.raw$control_se = dat.raw$control_sd / sqrt(dat.raw$control_n)
dat.raw$treat_se = dat.raw$treat_sd / sqrt(dat.raw$treat_n)
#############################################
# functions ---------------------------------
create.data.subset.function = function(data,data.sample.size.percentage){
data.sample.rows = sample(c(1:nrow(data)),nrow(data) * data.sample.size.percentage)
return(data[data.sample.rows,])
}
delete.function = function(dat.vector,deletion.rate,deletion.chance.vector){
dat.to.delete = sample(length(dat.vector), size= round(length(dat.vector) * deletion.rate), prob=deletion.chance.vector)
dat.vector[dat.to.delete] = NA
return(dat.vector)
}
impute.function =function(data.with.missing,column.name.with.missing.values,imputation.method){
if(!(imputation.method %in% "na.omit")){
data.complete = complete(mice(data.with.missing,method = imputation.method,
m=5, maxit =20, printFlag = FALSE))$treat_sd
}else{
data.complete = data.with.missing$treat_sd}
return(data.complete)
}
effect.size.calculation.function = function(data, effect.size.metric){
effect.sizes = escalc(measure = effect.size.metric, data= data, append = FALSE,
m1i = treat_mean, n1i = treat_n, sd1i = treat_sd, m2i = control_mean, n2i = control_n, sd2i = control_sd)
return(effect.sizes)
}
meta_analysis.function = function(data){
rma.temp = rma.uni(yi=data$yi,vi=data$vi,method="REML")
rma.temp.results = data.frame("grand_mean" = rma.temp$b[1],
"grand_mean_lb" = rma.temp$ci.lb[1],
"grand_mean_ub" = rma.temp$ci.ub[1],
"sample_size_for_rma_calc" = rma.temp$k[1])
return(rma.temp.results)
}
one.run.of.grand.mean.calculation.function = function(dat.temp, data.sample.size.percentage, del.rate.temp,
deletion.chance.slope,imputation.method.temp,effect.size.metric){
dat.temp =dat.raw
dat.temp = create.data.subset.function(dat.temp,data.sample.size.percentage)
del.chance.vector.temp = dat.temp$treat_mean * deletion.chance.slope
dat.temp$treat_sd = delete.function(dat.vector = dat.temp$treat_sd,
deletion.rate = del.rate.temp,
deletion.chance.vector = del.chance.vector.temp)
treat_sd.temp = tryCatch({
impute.function(data.with.missing = dat.temp[,c("biodiv_aspect","treat_mean","treat_sd","treat_n")],
column.name.with.missing.values = "treat_sd",
imputation.method = imputation.method.temp)
},error = function(e){
return(NA)
})
if(length(treat_sd.temp) == 1){
dat.temp$treat_sd = NA
}else{
dat.temp$treat_sd = treat_sd.temp
}
dat.temp = dat.temp[which(dat.temp$treat_sd >= 0),]
effect.sizes.temp = tryCatch({
effect.size.calculation.function(data = dat.temp,effect.size.metric = effect.size.metric)
}, error = function(e){
return(NA)
})
if(length(effect.sizes.temp) == 1){
effect.sizes.temp = data.frame("vi"=rep(NA, nrow(dat.temp)),"yi"=rep(NA, nrow(dat.temp)))}
#effect.sizes.temp = effect.sizes.temp[which(!(effect.sizes.temp$vi == 0)),] # probably not neccessary
data.missing.rma.results = tryCatch({
meta_analysis.function(effect.sizes.temp)
}, error = function(e){
return(NA)
})
if(length(data.missing.rma.results) == 1){
data.missing.rma.results =  data.frame("grand_mean" = NA,
"grand_mean_lb" = NA,
"grand_mean_ub" = NA,
"sample_size_for_rma_calc" = NA)}
data.size.temp <<- nrow(dat.temp)
return(data.missing.rma.results)
}
one.complete.imp.method.run = function(dat.raw,data.sample.size.percentage, imputation.method.temp,
deletion.chance.slope, deletion.minimum, deletion.maximum,
deletion.step, repetitions.per.step,effect.size.metric){
del.rate.vector = sort(rep(seq(from = deletion.minimum,to=deletion.maximum,by = deletion.step),repetitions.per.step))
result.df.one.imp.method = data.frame("deletion_rate"= NA,
"grand_mean"= NA,
"grand_mean_lb"= NA,
"grand_mean_ub"= NA,
"sample_size_for_rma_calc"=NA)[0,]
for(del.rate.temp in del.rate.vector){
result.one.run =  one.run.of.grand.mean.calculation.function(
dat.temp =dat.raw,
data.sample.size.percentage = data.sample.size.percentage,
del.rate.temp = del.rate.temp,
deletion.chance.slope = deletion.chance.slope,
imputation.method.temp = imputation.method.temp,
effect.size.metric = effect.size.metric)
result.df.one.run = data.frame("deletion_rate"= del.rate.temp,
"grand_mean"= result.one.run$grand_mean,
"grand_mean_lb"= result.one.run$grand_mean_lb,
"grand_mean_ub"= result.one.run$grand_mean_ub,
"sample_size_for_rma_calc"=result.one.run$sample_size_for_rma_calc)
result.df.one.imp.method = rbind(result.df.one.imp.method,result.df.one.run)
print(del.rate.temp)
}
return(result.df.one.imp.method)
}
run.over.all.methods = function(dat.raw , data.sample.size.percentage, imp.methods.vector,
deletion.chance.slope, deletion.minimum, deletion.maximum,
deletion.step, repetitions.per.step, data.size,effect.size.metric){
result.df = data.frame("imputation_method"=NA,"data_size"=NA,"deletion_rate"=NA,"effect_size"=NA,
"grand_mean"=NA,"grand_mean_lb"=NA,"grand_mean_ub"=NA,"sample_size_for_rma_calc"=NA)[0,]
for(method.temp in imp.methods.vector){
result.df.one.imp.method = one.complete.imp.method.run(dat.raw = dat.raw,
data.sample.size.percentage = data.sample.size.percentage,
imputation.method.temp = method.temp,
deletion.minimum = deletion.minimum,
deletion.maximum = deletion.maximum,
deletion.step = deletion.step,
repetitions.per.step = repetitions.per.step,
deletion.chance.slope = deletion.chance.slope,
effect.size.metric = effect.size.metric)
result.df.one.imp.method$imputation_method = method.temp
result.df.one.imp.method$data_size = data.sample.size.percentage
result.df.one.imp.method$effect_size = effect.size.metric
result.df = rbind(result.df, result.df.one.imp.method)
}
return(result.df)
}
#############################################
# config algorithm --------------------------
test = run.over.all.methods(dat.raw = dat.raw,
data.sample.size.percentage = 1,
imp.methods.vector = c("sample","mean","pmm","norm.nob","norm.boot","norm.predict","norm","cart","rf"),
deletion.chance.slope = 1,
deletion.minimum = 0.1,
deletion.maximum = 0.9,
deletion.step = 0.1,
repetitions.per.step = 1,
data.size = 1,
effect.size.metric = "ROM")
### Testing multiple imputation methods for estimating missing
### standard deviations in a real dataset
###
### Author: Stephan Kambach
### Date: 28.04.2015
#############################################
# libraries --------------------------------
library(mice)
#library(mi)
#library(Amelia)
#library(mitools)
#library(pan)
library(ggplot2)
library(metafor)
library(ROCR)
library(data.table)
#############################################
# read data ---------------------------------
dat.raw = read.csv("C:\\Users\\Agando\\Desktop\\aktuelle Arbeiten\\SESYNC_multiple_imputation\\LUBDES_multiple_imputations\\MA_Gerstner2014_complete_observations.csv",
header=T)
dat.raw = dat.raw[,-1]
str(dat.raw)
names(dat.raw) = c("reference","biodiv_aspect","control_n","treat_n","control_mean","treat_mean","control_sd","treat_sd")
#############################################
# cleaning and standard error calculation
dat.raw = dat.raw[-419,] # clear outlier
dat.raw = dat.raw[- which(duplicated(dat.raw)),]
dat.raw$control_se = dat.raw$control_sd / sqrt(dat.raw$control_n)
dat.raw$treat_se = dat.raw$treat_sd / sqrt(dat.raw$treat_n)
#############################################
# functions ---------------------------------
create.data.subset.function = function(data,data.sample.size.percentage){
data.sample.rows = sample(c(1:nrow(data)),nrow(data) * data.sample.size.percentage)
return(data[data.sample.rows,])
}
delete.function = function(dat.vector,deletion.rate,deletion.chance.vector){
dat.to.delete = sample(length(dat.vector), size= round(length(dat.vector) * deletion.rate), prob=deletion.chance.vector)
dat.vector[dat.to.delete] = NA
return(dat.vector)
}
impute.function =function(data.with.missing,column.name.with.missing.values,imputation.method){
if(!(imputation.method %in% "na.omit")){
data.complete = complete(mice(data.with.missing,method = imputation.method,
m=5, maxit =20, printFlag = FALSE))$treat_sd
}else{
data.complete = data.with.missing$treat_sd}
return(data.complete)
}
effect.size.calculation.function = function(data, effect.size.metric){
effect.sizes = escalc(measure = effect.size.metric, data= data, append = FALSE,
m1i = treat_mean, n1i = treat_n, sd1i = treat_sd, m2i = control_mean, n2i = control_n, sd2i = control_sd)
return(effect.sizes)
}
meta_analysis.function = function(data){
rma.temp = rma.uni(yi=data$yi,vi=data$vi,method="REML")
rma.temp.results = data.frame("grand_mean" = rma.temp$b[1],
"grand_mean_lb" = rma.temp$ci.lb[1],
"grand_mean_ub" = rma.temp$ci.ub[1],
"sample_size_for_rma_calc" = rma.temp$k[1])
return(rma.temp.results)
}
one.run.of.grand.mean.calculation.function = function(dat.temp, data.sample.size.percentage, del.rate.temp,
deletion.chance.slope,imputation.method.temp,effect.size.metric){
dat.temp =dat.raw
dat.temp = create.data.subset.function(dat.temp,data.sample.size.percentage)
del.chance.vector.temp = dat.temp$treat_mean * deletion.chance.slope
dat.temp$treat_sd = delete.function(dat.vector = dat.temp$treat_sd,
deletion.rate = del.rate.temp,
deletion.chance.vector = del.chance.vector.temp)
treat_sd.temp = tryCatch({
impute.function(data.with.missing = dat.temp[,c("biodiv_aspect","treat_mean","treat_sd","treat_n")],
column.name.with.missing.values = "treat_sd",
imputation.method = imputation.method.temp)
},error = function(e){
return(NA)
})
if(length(treat_sd.temp) == 1){
dat.temp$treat_sd = NA
}else{
dat.temp$treat_sd = treat_sd.temp
}
dat.temp = dat.temp[which(dat.temp$treat_sd >= 0),]
effect.sizes.temp = tryCatch({
effect.size.calculation.function(data = dat.temp,effect.size.metric = effect.size.metric)
}, error = function(e){
return(NA)
})
if(length(effect.sizes.temp) == 1){
effect.sizes.temp = data.frame("vi"=rep(NA, nrow(dat.temp)),"yi"=rep(NA, nrow(dat.temp)))}
#effect.sizes.temp = effect.sizes.temp[which(!(effect.sizes.temp$vi == 0)),] # probably not neccessary
data.missing.rma.results = tryCatch({
meta_analysis.function(effect.sizes.temp)
}, error = function(e){
return(NA)
})
if(length(data.missing.rma.results) == 1){
data.missing.rma.results =  data.frame("grand_mean" = NA,
"grand_mean_lb" = NA,
"grand_mean_ub" = NA,
"sample_size_for_rma_calc" = NA)}
data.size.temp <<- nrow(dat.temp)
return(data.missing.rma.results)
}
one.complete.imp.method.run = function(dat.raw,data.sample.size.percentage, imputation.method.temp,
deletion.chance.slope, deletion.minimum, deletion.maximum,
deletion.step, repetitions.per.step,effect.size.metric){
del.rate.vector = sort(rep(seq(from = deletion.minimum,to=deletion.maximum,by = deletion.step),repetitions.per.step))
result.df.one.imp.method = data.frame("deletion_rate"= NA,
"grand_mean"= NA,
"grand_mean_lb"= NA,
"grand_mean_ub"= NA,
"sample_size_for_rma_calc"=NA)[0,]
for(del.rate.temp in del.rate.vector){
result.one.run =  one.run.of.grand.mean.calculation.function(
dat.temp =dat.raw,
data.sample.size.percentage = data.sample.size.percentage,
del.rate.temp = del.rate.temp,
deletion.chance.slope = deletion.chance.slope,
imputation.method.temp = imputation.method.temp,
effect.size.metric = effect.size.metric)
result.df.one.run = data.frame("deletion_rate"= del.rate.temp,
"grand_mean"= result.one.run$grand_mean,
"grand_mean_lb"= result.one.run$grand_mean_lb,
"grand_mean_ub"= result.one.run$grand_mean_ub,
"sample_size_for_rma_calc"=result.one.run$sample_size_for_rma_calc)
result.df.one.imp.method = rbind(result.df.one.imp.method,result.df.one.run)
print(paste(del.rate.temp,imputation.method.temp,collapse="-"))
}
return(result.df.one.imp.method)
}
run.over.all.methods = function(dat.raw , data.sample.size.percentage, imp.methods.vector,
deletion.chance.slope, deletion.minimum, deletion.maximum,
deletion.step, repetitions.per.step, data.size,effect.size.metric){
result.df = data.frame("imputation_method"=NA,"data_size"=NA,"deletion_rate"=NA,"effect_size"=NA,
"grand_mean"=NA,"grand_mean_lb"=NA,"grand_mean_ub"=NA,"sample_size_for_rma_calc"=NA)[0,]
for(method.temp in imp.methods.vector){
result.df.one.imp.method = one.complete.imp.method.run(dat.raw = dat.raw,
data.sample.size.percentage = data.sample.size.percentage,
imputation.method.temp = method.temp,
deletion.minimum = deletion.minimum,
deletion.maximum = deletion.maximum,
deletion.step = deletion.step,
repetitions.per.step = repetitions.per.step,
deletion.chance.slope = deletion.chance.slope,
effect.size.metric = effect.size.metric)
result.df.one.imp.method$imputation_method = method.temp
result.df.one.imp.method$data_size = data.sample.size.percentage
result.df.one.imp.method$effect_size = effect.size.metric
result.df = rbind(result.df, result.df.one.imp.method)
}
return(result.df)
}
#############################################
# config algorithm --------------------------
test = run.over.all.methods(dat.raw = dat.raw,
data.sample.size.percentage = 1,
imp.methods.vector = c("sample","mean","pmm","norm.nob","norm.boot","norm.predict","norm","cart","rf"),
deletion.chance.slope = 1,
deletion.minimum = 0.1,
deletion.maximum = 0.9,
deletion.step = 0.1,
repetitions.per.step = 1,
data.size = 1,
effect.size.metric = "ROM")
warnings
warnings()
test
plot(grand_mean_ub - grand_mean_lb ~ imputation_method,data=test)
plot((grand_mean_ub - grand_mean_lb) ~ imputation_method,data=test)
test2 = test$grand_mean_lb + test$grand_mean_ub
test2
test2 = test$grand_mean_ub + test$grand_mean_lb
test2
test2 = test$grand_mean_ub - test$grand_mean_lb
test2
plot(test2 ~ test$imputation_method)
str(test)
plot(test2 ~ as.factor(test$imputation_method))
df.final = run.over.all.methods(dat.raw = dat.raw,
data.sample.size.percentage = 1,
imp.methods.vector = c("sample","mean","pmm","norm.nob","norm.boot","norm.predict","norm","cart","rf"),
deletion.chance.slope = 1,
deletion.minimum = 0.2,
deletion.maximum = 0.98,
deletion.step = 0.01,
repetitions.per.step = 2,
data.size = 1,
effect.size.metric = "ROM")
write.table(df.final,"C:\\Users\\Agando\\Desktop\\aktuelle Arbeiten\\SESYNC_multiple_imputation\\LUBDES_multiple_imputations\\all_methods_non_random_full_data.csv",
sep="\t",quote=F,dec=".",row.names = FALSE)
df.final
test = df.final$grand_mean_ub - df.final$grand_mean_ub
plot(test ~ df.final$imputation_method)
test = df.final$grand_mean_ub - df.final$grand_mean_ub
plot(test ~ factor(df.final$imputation_method))
test = df.final$grand_mean_ub - df.final$grand_mean_lb
plot(test ~ factor(df.final$imputation_method))
